<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java多线程 - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-09-25T13:37:01.000Z">September 25, 2017</time><h1 class="post__title"><a href="/2017/09/25/Java多线程/">Java多线程</a></h1><div class="post__main echo"><p>什么是进程？什么是线程？<br>进程是计算机中的程序关于某数据集合的一次运行活动，线程是程序执行流的最小单元。简而言之，一个程序至少有一个进程，在一个进程之中至少有一个线程。</p>
<p>我们今天来分析多线程的知识，多线程是用来干什么的？<br>1、更好的利用cpu资源。我们的计算机对数据什么的操作不是在同一个位置进行的，一般来说，先读取，再执行操作，最后输出。如果是以这种流程的话，我们很容易就能看到，在读取输出的时候，我们的cpu是没有进行操作的，这就造成了资源浪费。<br>上帝说，浪费是可耻的，所以，我们便有了多线程。在一个线程进行操作时，添加上另一线程，从而省去部分等待的时间。（有点像我们小时候的奥数题，如何最快速度煮茶水，先把水倒去煮，然后同时洗茶壶杯子放茶叶。。。）<br>2、如果我们的程序有多个角色，比如说现在我们玩的游戏，开两个号，一个号用来练级，另一个号走路领任务，这时候，为了反映多角色，所以我们也需要使用多线程（这只是例子，不要当真。。。）</p>
<p>现在，先建立一下数据字典（别人建的）：<br>1、多线程：一个进程运行时产生了不止一个线程<br>2、并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。（所谓双核四核的作用）<br>3、并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br>4、线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void transferMoney(User from, User to, float amount)&#123;</div><div class="line">  to.setMoney(to.getBalance() + amount);</div><div class="line">  from.setMoney(from.getBalance() - amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>银行如果是这样的代码的话，我会马上过去取钱的，当运行时突然出现了错误，这时候只执行了第一行，拿到钱，第二行没有执行，那么意味着你可以一直取钱，账户金额一直不变。（你想太多了）<br>所以呢，我看了一下解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public int delete(int sID) &#123;</div><div class="line">　 dbc = new DataBaseConnection();</div><div class="line">　 Connection con = dbc.getConnection();</div><div class="line">　 try &#123;</div><div class="line">　　 con.setAutoCommit(false);// 更改JDBC事务的默认提交方式</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_content where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_affix where bylawid=&quot; + sID);</div><div class="line">　　 con.commit();//提交JDBC事务</div><div class="line">　　 con.setAutoCommit(true);// 恢复JDBC事务的默认提交方式</div><div class="line">　　 dbc.close();</div><div class="line">　　 return 1;</div><div class="line">　 &#125;</div><div class="line">　 catch (Exception exc) &#123;</div><div class="line">　　 con.rollBack();//回滚JDBC事务</div><div class="line">　　 exc.printStackTrace();</div><div class="line">　　 dbc.close();</div><div class="line">　　 return -1;</div><div class="line">　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，我们先阻止事务默认提交，然后自己依次提交，当提交出现异常时，将之前的操作回滚，这样就会实现事务的原子性了（少了一条赚钱的方式。。。）这是一个比较简陋 的方法，后期可以使用框架什么的来实现<br>5、同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p><font size="5">我们来看一下线程的生命周期</font><br>这个很重要，毕竟八成面试会问，没图说个…（和谐），来先上图<br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/Thread/ThreadLife.png?raw=true" alt="ThreadLife"><br>线程的生命周期可以分为五个状态：</p>
<p>1.创建状态：<br>　　当用new操作符创建一个新的线程对象时，该线程处于创建状态。<br>　　处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。</p>
<p>2.就绪状态：<br>　　执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体——run()方法，这样就使得该线程处于可运行状态（Runnable）。<br>　　这一状态并不是运行中状态（Running），因为线程也许实际上并未真正运行。</p>
<p>3.运行状态<br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>4.堵塞状态：<br>　　当发生下列事件时，处于运行状态的线程会转入到不可运行状态：<br>　　调用了sleep()方法；<br>　　线程调用wait()方法等待特定条件的满足；<br>　　线程输入/输出阻塞。<br>　　返回可运行状态：<br>　　处于睡眠状态的线程在指定的时间过去后；<br>　　如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变；<br>　　如果线程是因为输入输出阻塞，等待输入输出完成。</p>
<p>4.消亡状态：<br>　　当线程的run()方法执行结束后，该线程自然消亡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">public class TestThread &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">    //new方法一：也可以用这种方法new</div><div class="line">//		Thread1 thread1 = new Thread1();</div><div class="line">//new方法二：创建状态，现在并没有什么用</div><div class="line">		Thread thread1 = new Thread(new Thread1());</div><div class="line">		Thread thread2 = new Thread(new Thread2());</div><div class="line">//可运行状态，要使用start()，不能用run()，否则只是调用名为run()的方法而不是执行线程</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第一种方法：继承Thread</div><div class="line">class Thread1 extends Thread&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i &lt; 100;i++)&#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第二种方法：实现runnable接口，这一种不能使用new方法一，否则start()会报错</div><div class="line">class Thread2 implements Runnable&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i&lt;100;i++)&#123;</div><div class="line">			System.out.println(i+&quot;2&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>