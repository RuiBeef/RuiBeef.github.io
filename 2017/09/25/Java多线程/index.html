<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java多线程 - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-09-25T13:37:01.000Z">September 25, 2017</time><h1 class="post__title"><a href="/2017/09/25/Java多线程/">Java多线程</a></h1><div class="post__main echo"><p>什么是进程？什么是线程？<br>进程是计算机中的程序关于某数据集合的一次运行活动，线程是程序执行流的最小单元。简而言之，一个程序至少有一个进程，在一个进程之中至少有一个线程。</p>
<p>我们今天来分析多线程的知识，多线程是用来干什么的？<br>1、更好的利用cpu资源。我们的计算机对数据什么的操作不是在同一个位置进行的，一般来说，先读取，再执行操作，最后输出。如果是以这种流程的话，我们很容易就能看到，在读取输出的时候，我们的cpu是没有进行操作的，这就造成了资源浪费。<br>上帝说，浪费是可耻的，所以，我们便有了多线程。在一个线程进行操作时，添加上另一线程，从而省去部分等待的时间。（有点像我们小时候的奥数题，如何最快速度煮茶水，先把水倒去煮，然后同时洗茶壶杯子放茶叶。。。）<br>2、如果我们的程序有多个角色，比如说现在我们玩的游戏，开两个号，一个号用来练级，另一个号走路领任务，这时候，为了反映多角色，所以我们也需要使用多线程（这只是例子，不要当真，真正的游戏设计比这个复杂多了。。。）</p>
<p>现在，先建立一下数据字典（别人建的）：<br>1、多线程：一个进程运行时产生了不止一个线程<br>2、并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。（所谓双核四核的作用）<br>3、并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br>4、线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void transferMoney(User from, User to, float amount)&#123;</div><div class="line">  to.setMoney(to.getBalance() + amount);</div><div class="line">  from.setMoney(from.getBalance() - amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>银行如果是这样的代码的话，我会马上过去取钱的，当运行时突然出现了错误，这时候只执行了第一行，拿到钱，第二行没有执行，那么意味着你可以一直取钱，账户金额一直不变。（你想太多了）<br>所以呢，我看了一下解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public int delete(int sID) &#123;</div><div class="line">　 dbc = new DataBaseConnection();</div><div class="line">　 Connection con = dbc.getConnection();</div><div class="line">　 try &#123;</div><div class="line">　　 con.setAutoCommit(false);// 更改JDBC事务的默认提交方式</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_content where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_affix where bylawid=&quot; + sID);</div><div class="line">　　 con.commit();//提交JDBC事务</div><div class="line">　　 con.setAutoCommit(true);// 恢复JDBC事务的默认提交方式</div><div class="line">　　 dbc.close();</div><div class="line">　　 return 1;</div><div class="line">　 &#125;</div><div class="line">　 catch (Exception exc) &#123;</div><div class="line">　　 con.rollBack();//回滚JDBC事务</div><div class="line">　　 exc.printStackTrace();</div><div class="line">　　 dbc.close();</div><div class="line">　　 return -1;</div><div class="line">　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，我们先阻止事务默认提交，然后自己依次提交，当提交出现异常时，将之前的操作回滚，这样就会实现事务的原子性了（少了一条赚钱的方式。。。）这是一个比较简陋 的方法，后期可以使用框架什么的来实现<br>5、同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p><font size="5">我们来看一下线程的生命周期</font><br>这个很重要，毕竟八成面试会问，没图说个…（和谐），来先上图<br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/Thread/ThreadLife.png?raw=true" alt="ThreadLife"><br>线程的生命周期可以分为五个状态：</p>
<p>1.创建状态：<br>　　当用new操作符创建一个新的线程对象时，该线程处于创建状态。<br>　　处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。</p>
<p>2.就绪状态：<br>　　执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体——run()方法，这样就使得该线程处于可运行状态（Runnable）。<br>　　这一状态并不是运行中状态（Running），因为线程也许实际上并未真正运行。</p>
<p>3.运行状态<br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>4.堵塞状态：<br>　　当发生下列事件时，处于运行状态的线程会转入到不可运行状态：<br>　　调用了sleep()方法；<br>　　线程调用wait()方法等待特定条件的满足；<br>　　线程输入/输出阻塞。<br>　　返回可运行状态：<br>　　处于睡眠状态的线程在指定的时间过去后；<br>　　如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变；<br>　　如果线程是因为输入输出阻塞，等待输入输出完成。</p>
<p>4.消亡状态：<br>　　当线程的run()方法执行结束后，该线程自然消亡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">public class TestThread &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">    //new方法一：也可以用这种方法new</div><div class="line">//		Thread1 thread1 = new Thread1();</div><div class="line">//new方法二：创建状态，现在并没有什么用</div><div class="line">		Thread thread1 = new Thread(new Thread1());</div><div class="line">		Thread thread2 = new Thread(new Thread2());</div><div class="line">//可运行状态，要使用start()，不能用run()，否则只是调用名为run()的方法而不是执行线程</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第一种方法：继承Thread</div><div class="line">class Thread1 extends Thread&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i &lt; 100;i++)&#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第二种方法：实现runnable接口，这一种不能使用new方法一，否则start()会报错</div><div class="line">class Thread2 implements Runnable&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i&lt;100;i++)&#123;</div><div class="line">			System.out.println(i+&quot;2&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于各个方法：<br>1、sleep()<br>　　使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。<br>例如有两个线程同时执行(没有synchronized)一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。</p>
<p>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">			sleep(100);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			// TODO Auto-generated catch block</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>2、join()<br>　　join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。</p>
<p>下面是join的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line">public class Test implements Runnable&#123;</div><div class="line">	public static int a = 0;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		for(int i = 0;i&lt;100;i++)&#123;</div><div class="line">			a++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">   public static void main(String[] args) throws InterruptedException&#123;</div><div class="line">    	Thread t = new Thread(new Test());</div><div class="line">    	t.start();</div><div class="line">  //  	t.join(0);</div><div class="line">    	System.out.println(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上这种情况，我们运行时出现a=100的次数极少，原因就是（我自己猜的）：当主线程 main方法执行System.out.println(a);这条语句时，线程还没有真正开始运行，或许正在为它分配资源准备运行。因为为线程分配资源需要时间，而main方法执行完t.start()方法后继续往下执行System.out.println(a);这个时候得到的结果是a还没有被改变的值0<br>所以，这个时候join()的作用出现了，我们添加上join()同时抛出InterruptedException，这时，表示的是先等实例化的t对象运行结束，之后才运行mian中的语句。</p>
<p>3、yield()<br>　　该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。<br>　　有人举了个蛮生动的例子：现在有很多人在排队上厕所，好不容易轮到这个人上厕所了，突然这个人说：“我要和大家来个竞赛，看谁先抢到厕所！”，然后所有的人在同一起跑线冲向厕所，有可能是别人抢到了，也有可能他自己有抢到了。我们还知道线程有个优先级的问题，那么手里有优先权的这些人就一定能抢到厕所的位置吗? 不一定的，他们只是概率上大些，也有可能没特权的抢到了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yield();</div></pre></td></tr></table></figure></p>
<p>4、wait()和notify()、notifyAll()<br>　　这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。<br>wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。<br>notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。<br>注意 这三个方法都是java.lang.Object的方法。</p>
<p>5、run和start()<br>　　把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。</p>
<p>6、关键字synchronized<br>　　该关键字用于保护共享数据，当然前提条件是要分清哪些数据是共享数据。每个对象都有一个锁标志，当一个线程访问到该对象，被Synchronized修饰的数据将被”上锁”，阻止其他线程访问。当前线程访问完这部分数据后释放锁标志，其他线程就可以访问了。</p>
<p>7、wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。</p>
<p>8、wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会！</p>
<p><font size="5">Synchronized解析</font><br>现在，我们来看这个困扰我多。。。天的synchronized<br>这个家伙的中文是“同步的”，事实上，我们一般叫它同步锁<br>先丢个代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">class SyncThread implements Runnable &#123;</div><div class="line">	private static int count;</div><div class="line"></div><div class="line">	public SyncThread() &#123;</div><div class="line">		count = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void run() &#123;</div><div class="line">		synchronized (this) &#123;</div><div class="line">			for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">				try &#123;</div><div class="line">					System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">					Thread.sleep(100);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCount() &#123;</div><div class="line">		return count;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SynTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SyncThread syncThread = new SyncThread();</div><div class="line">		Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);</div><div class="line">		Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);</div><div class="line">//		Thread thread1 = new Thread(new SyncThread(), &quot;SyncThread1&quot;);</div><div class="line">//		Thread thread2 = new Thread(new SyncThread(), &quot;SyncThread2&quot;);</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如图<br><img src="" alt="synp"></p>
<p>我们可以看到，这时候synchronized将for循环进行同步，在for执行过程中，其他方法无法调用，直到该方法执行结束<br>但是，如果把<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);</div></pre></td></tr></table></figure></p>
<p>换成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread thread1 = new Thread(new SyncThread(), &quot;SyncThread1&quot;);</div><div class="line">Thread thread2 = new Thread(new SyncThread(), &quot;SyncThread2&quot;);</div></pre></td></tr></table></figure></p>
<p>这时候输出如下图：<br><img src="" alt="Synp2"><br>说好的加锁呢？<br>其实我们从上述两段代码可以看出，后一段代码是执行两个不同对象中的锁，而我们的this只会锁定本对象的代码块，所以，我们在编写锁的时候要注意，不要编写错锁的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">class SyncThread implements Runnable &#123;</div><div class="line">	private static int count;</div><div class="line"></div><div class="line">	public SyncThread() &#123;</div><div class="line">		count = 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void run() &#123;</div><div class="line">		method();</div><div class="line">	&#125;</div><div class="line">	synchronized public static void method()&#123;</div><div class="line"></div><div class="line">		for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">				try &#123;</div><div class="line">					System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++));</div><div class="line">					Thread.sleep(100);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int getCount() &#123;</div><div class="line">		return count;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class SynTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SyncThread syncThread = new SyncThread();</div><div class="line">//		Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);</div><div class="line">//		Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);</div><div class="line">		Thread thread1 = new Thread(new SyncThread(), &quot;SyncThread1&quot;);</div><div class="line">		Thread thread2 = new Thread(new SyncThread(), &quot;SyncThread2&quot;);</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="" alt="Synp3"><br>我将synchronized定义成一个static方法，同时，使用run()调用该方法，由于该方法是静态且加锁的，所以执行的时候会阻止其他线程调用</p>
<p>现在，我们由上述代码可以知道，每个实例对象有一个对象锁，这个对象锁只能锁定该实例内部，而不是一次性将所有关联项进行锁定，这样的好处就是方便我们进行比较细致的锁，而不会影响大段无关联代码，提高了cpu运行的效率。</p>
<p>synchronized 方法控制对类成员变量的访问：<br>每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">public class CounterTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Counter counter  = new Counter();</div><div class="line">		Thread thread1 = new Thread(counter,&quot;A&quot;);</div><div class="line">		Thread thread2 = new Thread(counter,&quot;B&quot;);</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Counter implements Runnable&#123;</div><div class="line">	private int count;</div><div class="line">	public Counter()&#123;</div><div class="line">		count = 0;</div><div class="line">	&#125;</div><div class="line">	public void countAdd()&#123;</div><div class="line">		synchronized(this)&#123;</div><div class="line">			for(int i = 0;i&lt;5;i++)&#123;</div><div class="line">				try&#123;</div><div class="line">					System.out.println(Thread.currentThread().getName()+&quot;:&quot;+(count++));</div><div class="line">					Thread.sleep(100);</div><div class="line">				&#125;catch(InterruptedException e)&#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void printCount()&#123;</div><div class="line">		for(int i = 0;i&lt;5;i++)&#123;</div><div class="line">			try&#123;</div><div class="line">				System.out.println(Thread.currentThread().getName()+&quot;count:&quot;+(count++));</div><div class="line">				Thread.sleep(100);</div><div class="line">			&#125;catch(InterruptedException e)&#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		String threadName = Thread.currentThread().getName();</div><div class="line">		if(threadName.equals(&quot;A&quot;))&#123;</div><div class="line">			countAdd();</div><div class="line">		&#125;else if(threadName.equals(&quot;B&quot;))&#123;</div><div class="line">			printCount();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="" alt="Synp4"><br>我们通过run()方法进行判断，当线程名称为A时，使用同步代码块，为B时，使用非同步的代码块，这时我们可以看到，一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">public class AccountTest &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Account account = new Account(&quot;zhang san&quot;,10000.0f);</div><div class="line">		AccountOperator ao = new AccountOperator(account);</div><div class="line">		final int THREAD_NUM = 5;</div><div class="line">		Thread threads[] = new Thread[THREAD_NUM];</div><div class="line">		for(int i = 0;i&lt;THREAD_NUM;i++)&#123;</div><div class="line">			threads[i] = new Thread(ao,&quot;Thread&quot;+i);</div><div class="line">			threads[i].start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Account&#123;</div><div class="line">	String name;</div><div class="line">	float amount;</div><div class="line">	public Account(String name,float amount)&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.amount = amount;</div><div class="line">	&#125;</div><div class="line">	public void deposit(float amt)&#123;</div><div class="line">		amount += amt;</div><div class="line">//		try&#123;</div><div class="line">//			Thread.sleep(1000);</div><div class="line">//		&#125;catch(InterruptedException e)&#123;</div><div class="line">//			e.printStackTrace();</div><div class="line">//		&#125;</div><div class="line">	&#125;</div><div class="line">	public void withdraw(float amt)&#123;</div><div class="line">		amount -= amt;</div><div class="line">//		try&#123;</div><div class="line">//			Thread.sleep(1000);</div><div class="line">//		&#125;catch(InterruptedException e)&#123;</div><div class="line">//			e.printStackTrace();</div><div class="line">//		&#125;</div><div class="line">	&#125;</div><div class="line">	public float getBalance()&#123;</div><div class="line">		return amount;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class AccountOperator implements Runnable&#123;</div><div class="line">	private Account account;</div><div class="line">	public AccountOperator(Account account)&#123;</div><div class="line">		this.account = account;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		synchronized(account)&#123;</div><div class="line">			account.deposit(500);</div><div class="line">			account.withdraw(400);</div><div class="line">			System.out.println(Thread.currentThread().getName()+&quot;:&quot;+account.getBalance());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="" alt="Synp5"><br>这是关于银行的存取（总是想破解银行的代码，这样不好）<br>我们可以看到，当有五个线程同时操作该账户，由于在run()中加了锁，所以每次只能取一个进行操作，这大大保证了存取的安全</p>
<p>当有一个明确的对象作为锁时，就可以用类似下面这样的方式写程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void method3(SomeObject obj)</div><div class="line">&#123;</div><div class="line">   //obj 锁定的对象</div><div class="line">   synchronized(obj)</div><div class="line">   &#123;</div><div class="line">      // todo</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Test implements Runnable</div><div class="line">&#123;</div><div class="line">   private byte[] lock = new byte[0];  // 特殊的instance变量</div><div class="line">   public void method()</div><div class="line">   &#123;</div><div class="line">      synchronized(lock) &#123;</div><div class="line">         // todo 同步代码块</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void run() &#123;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>