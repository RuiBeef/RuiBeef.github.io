<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java多线程 - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-09-25T13:37:01.000Z">September 25, 2017</time><h1 class="post__title"><a href="/2017/09/25/Java多线程/">Java多线程</a></h1><div class="post__main echo"><p>什么是进程？什么是线程？<br>进程是计算机中的程序关于某数据集合的一次运行活动，线程是程序执行流的最小单元。简而言之，一个程序至少有一个进程，在一个进程之中至少有一个线程。</p>
<p>我们今天来分析多线程的知识，多线程是用来干什么的？<br>1、更好的利用cpu资源。我们的计算机对数据什么的操作不是在同一个位置进行的，一般来说，先读取，再执行操作，最后输出。如果是以这种流程的话，我们很容易就能看到，在读取输出的时候，我们的cpu是没有进行操作的，这就造成了资源浪费。<br>上帝说，浪费是可耻的，所以，我们便有了多线程。在一个线程进行操作时，添加上另一线程，从而省去部分等待的时间。（有点像我们小时候的奥数题，如何最快速度煮茶水，先把水倒去煮，然后同时洗茶壶杯子放茶叶。。。）<br>2、如果我们的程序有多个角色，比如说现在我们玩的游戏，开两个号，一个号用来练级，另一个号走路领任务，这时候，为了反映多角色，所以我们也需要使用多线程（这只是例子，不要当真。。。）</p>
<p>现在，先建立一下数据字典（别人建的）：<br>1、多线程：一个进程运行时产生了不止一个线程<br>2、并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。（所谓双核四核的作用）<br>3、并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<br>4、线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void transferMoney(User from, User to, float amount)&#123;</div><div class="line">  to.setMoney(to.getBalance() + amount);</div><div class="line">  from.setMoney(from.getBalance() - amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>银行如果是这样的代码的话，我会马上过去取钱的，当运行时突然出现了错误，这时候只执行了第一行，拿到钱，第二行没有执行，那么意味着你可以一直取钱，账户金额一直不变。（你想太多了）<br>所以呢，我看了一下解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public int delete(int sID) &#123;</div><div class="line">　 dbc = new DataBaseConnection();</div><div class="line">　 Connection con = dbc.getConnection();</div><div class="line">　 try &#123;</div><div class="line">　　 con.setAutoCommit(false);// 更改JDBC事务的默认提交方式</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_content where ID=&quot; + sID);</div><div class="line">　　 dbc.executeUpdate(&quot;delete from xiao_affix where bylawid=&quot; + sID);</div><div class="line">　　 con.commit();//提交JDBC事务</div><div class="line">　　 con.setAutoCommit(true);// 恢复JDBC事务的默认提交方式</div><div class="line">　　 dbc.close();</div><div class="line">　　 return 1;</div><div class="line">　 &#125;</div><div class="line">　 catch (Exception exc) &#123;</div><div class="line">　　 con.rollBack();//回滚JDBC事务</div><div class="line">　　 exc.printStackTrace();</div><div class="line">　　 dbc.close();</div><div class="line">　　 return -1;</div><div class="line">　 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，我们先阻止事务默认提交，然后自己依次提交，当提交出现异常时，将之前的操作回滚，这样就会实现事务的原子性了（少了一条赚钱的方式。。。）这是一个比较简陋 的方法，后期可以使用框架什么的来实现<br>5、同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p><font size="5">我们来看一下线程的生命周期</font><br>这个很重要，毕竟八成面试会问，没图说个…（和谐），来先上图<br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/Thread/ThreadLife.png?raw=true" alt="ThreadLife"><br>线程的生命周期可以分为五个状态：</p>
<p>1.创建状态：<br>　　当用new操作符创建一个新的线程对象时，该线程处于创建状态。<br>　　处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。</p>
<p>2.就绪状态：<br>　　执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体——run()方法，这样就使得该线程处于可运行状态（Runnable）。<br>　　这一状态并不是运行中状态（Running），因为线程也许实际上并未真正运行。</p>
<p>3.运行状态<br>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
<p>4.堵塞状态：<br>　　当发生下列事件时，处于运行状态的线程会转入到不可运行状态：<br>　　调用了sleep()方法；<br>　　线程调用wait()方法等待特定条件的满足；<br>　　线程输入/输出阻塞。<br>　　返回可运行状态：<br>　　处于睡眠状态的线程在指定的时间过去后；<br>　　如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变；<br>　　如果线程是因为输入输出阻塞，等待输入输出完成。</p>
<p>4.消亡状态：<br>　　当线程的run()方法执行结束后，该线程自然消亡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">public class TestThread &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">    //new方法一：也可以用这种方法new</div><div class="line">//		Thread1 thread1 = new Thread1();</div><div class="line">//new方法二：创建状态，现在并没有什么用</div><div class="line">		Thread thread1 = new Thread(new Thread1());</div><div class="line">		Thread thread2 = new Thread(new Thread2());</div><div class="line">//可运行状态，要使用start()，不能用run()，否则只是调用名为run()的方法而不是执行线程</div><div class="line">		thread1.start();</div><div class="line">		thread2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第一种方法：继承Thread</div><div class="line">class Thread1 extends Thread&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i &lt; 100;i++)&#123;</div><div class="line">			System.out.println(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//第二种方法：实现runnable接口，这一种不能使用new方法一，否则start()会报错</div><div class="line">class Thread2 implements Runnable&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int i = 0;i&lt;100;i++)&#123;</div><div class="line">			System.out.println(i+&quot;2&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于各个方法：<br>1、sleep()<br>　　使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。<br>例如有两个线程同时执行(没有synchronized)一个线程优先级为MAX_PRIORITY，另一个为MIN_PRIORITY，如果没有Sleep()方法，只有高优先级的线程执行完毕后，低优先级的线程才能够执行；但是高优先级的线程sleep(500)后，低优先级就有机会执行了。</p>
<p>总之，sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</p>
<p>2、join()<br>　　join()方法使调用该方法的线程在此之前执行完毕，也就是等待该方法的线程执行完毕后再往下继续执行。注意该方法也需要捕捉异常。</p>
<p>3、yield()<br>　　该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。</p>
<p>4、wait()和notify()、notifyAll()<br>　　这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。<br>wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。<br>notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。<br>注意 这三个方法都是java.lang.Object的方法。</p>
<p>5、run和start()<br>　　把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的。并且run()方法必需是public访问权限，返回值类型为void。</p>
<p>6、关键字synchronized<br>　　该关键字用于保护共享数据，当然前提条件是要分清哪些数据是共享数据。每个对象都有一个锁标志，当一个线程访问到该对象，被Synchronized修饰的数据将被”上锁”，阻止其他线程访问。当前线程访问完这部分数据后释放锁标志，其他线程就可以访问了。<br>7、wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>