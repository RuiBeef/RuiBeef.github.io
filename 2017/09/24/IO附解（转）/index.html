<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>IO附解（转） - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-09-24T11:26:21.000Z">September 24, 2017</time><h1 class="post__title"><a href="/2017/09/24/IO附解（转）/">IO附解（转）</a></h1><div class="post__main echo"><p>随机读取File文件</p>
<p>通过上面的例子我们已经知道，我们可以用FileInputStream（文件字符流）或FileReader（文件字节流）来读文件，这两个类可以让我们分别以字符和字节的方式来读取文件内容，但是它们都有一个不足之处，就是只能从文件头开始读，然后读到文件结束。</p>
<p>但是有时候我们只希望读取文件的一部分，或者是说随机的读取文件，那么我们就可以利用RandomAccessFile。RandomAccessFile提供了seek()方法，用来定位将要读写文件的指针位置，我们也可以通过调用getFilePointer()方法来获取当前指针的位置，具体看下面的例子:<br>随机读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void randomAccessFileRead() throws IOException &#123;</div><div class="line">         // 创建一个RandomAccessFile对象</div><div class="line">        RandomAccessFile file = new RandomAccessFile( &quot;d:/test.txt&quot;, &quot;rw&quot;);</div><div class="line">         // 通过seek方法来移动读写位置的指针</div><div class="line">         file.seek(10);</div><div class="line">         // 获取当前指针</div><div class="line">         long pointerBegin = file.getFilePointer();</div><div class="line">         // 从当前指针开始读</div><div class="line">         byte[] contents = new byte[1024];</div><div class="line">         file.read( contents);</div><div class="line">         long pointerEnd = file.getFilePointer();</div><div class="line">        System. out.println( &quot;pointerBegin:&quot; + pointerBegin + &quot;\n&quot; + &quot;pointerEnd:&quot; + pointerEnd + &quot;\n&quot; + new String(contents));</div><div class="line">         file.close();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>随机写入文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public static void randomAccessFileWrite() throws IOException &#123;</div><div class="line">        // 创建一个RandomAccessFile对象</div><div class="line">       RandomAccessFile file = new RandomAccessFile( &quot;d:/test.txt&quot;, &quot;rw&quot;);</div><div class="line">        // 通过seek方法来移动读写位置的指针</div><div class="line">        file.seek(10);</div><div class="line">        // 获取当前指针</div><div class="line">        long pointerBegin = file.getFilePointer();</div><div class="line">        // 从当前指针位置开始写</div><div class="line">        file.write( &quot;HELLO WORD&quot;.getBytes());</div><div class="line">        long pointerEnd = file.getFilePointer();</div><div class="line">       System. out.println( &quot;pointerBegin:&quot; + pointerBegin + &quot;\n&quot; + &quot;pointerEnd:&quot; + pointerEnd + &quot;\n&quot; );</div><div class="line">        file.close();</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>Java IO：管道媒介<br>管道主要用来实现同一个虚拟机中的两个线程进行交流。因此，一个管道既可以作为数据源媒介也可作为目标媒介。</p>
<p>需要注意的是java中的管道和Unix/Linux中的管道含义并不一样，在Unix/Linux中管道可以作为两个位于不同空间进程通信的媒介，而在java中，管道只能为同一个JVM进程中的不同线程进行通信。和管道相关的IO类为：PipedInputStream和PipedOutputStream，下面我们来看一个例子：<br>读写管道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class PipeExample &#123;</div><div class="line">   public static void main(String[] args) throws IOException &#123;</div><div class="line">          final PipedOutputStream output = new PipedOutputStream();</div><div class="line">          final PipedInputStream  input  = new PipedInputStream(output);</div><div class="line">          Thread thread1 = new Thread( new Runnable() &#123;</div><div class="line">              @Override</div><div class="line">              public void run() &#123;</div><div class="line">                  try &#123;</div><div class="line">                      output.write( &quot;Hello world, pipe!&quot;.getBytes());</div><div class="line">                  &#125; catch (IOException e) &#123;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;);</div><div class="line">          Thread thread2 = new Thread( new Runnable() &#123;</div><div class="line">              @Override</div><div class="line">              public void run() &#123;</div><div class="line">                  try &#123;</div><div class="line">                      int data = input.read();</div><div class="line">                      while( data != -1)&#123;</div><div class="line">                          System. out.print(( char) data);</div><div class="line">                          data = input.read();</div><div class="line">                      &#125;</div><div class="line">                  &#125; catch (IOException e) &#123;</div><div class="line">                  &#125; finally&#123;</div><div class="line">                     try &#123;</div><div class="line">                                       input.close();</div><div class="line">                                &#125; catch (IOException e) &#123;</div><div class="line">                                       e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;);</div><div class="line">          thread1.start();</div><div class="line">          thread2.start();</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>Java IO：网络媒介</p>
<p>关于Java IO面向网络媒介的操作即Java 网络编程，其核心是Socket，同磁盘操作一样，java网络编程对应着两套API，即Java IO和Java NIO，关于这部分我会准备专门的文章进行介绍。</p>
<p>Java IO：BufferedInputStream和BufferedOutputStream</p>
<p>BufferedInputStream顾名思义，就是在对流进行写入时提供一个buffer来提高IO效率。在进行磁盘或网络IO时，原始的InputStream对数据读取的过程都是一个字节一个字节操作的，而BufferedInputStream在其内部提供了一个buffer，在读数据时，会一次读取一大块数据到buffer中，这样比单字节的操作效率要高的多，特别是进程磁盘IO和对大量数据进行读写的时候。</p>
<p>使用BufferedInputStream十分简单，只要把普通的输入流和BufferedInputStream组合到一起即可。我们把上面的例2改造成用BufferedInputStream进行读文件，请看下面例子：<br>用缓冲流读文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void readByBufferedInputStream() throws IOException &#123;</div><div class="line">        File file = new File( &quot;d:/test.txt&quot;);</div><div class="line">         byte[] byteArray = new byte[( int) file.length()];</div><div class="line">         //可以在构造参数中传入buffer大小</div><div class="line">        InputStream is = new BufferedInputStream( new FileInputStream(file),2*1024);</div><div class="line">         int size = is.read( byteArray);</div><div class="line">        System. out.println( &quot;大小:&quot; + size + &quot;;内容:&quot; + new String(byteArray));</div><div class="line">         is.close();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>关于如何设置buffer的大小，我们应根据我们的硬件状况来确定。对于磁盘IO来说，如果硬盘每次读取4KB大小的文件块，那么我们最好设置成这个大小的整数倍。因为磁盘对于顺序读的效率是特别高的，所以如果buffer再设置的大写可能会带来更好的效率，比如设置成4<em>4KB或8</em>4KB。</p>
<p>还需要注意一点的就是磁盘本身就会有缓存，在这种情况下，BufferedInputStream会一次读取磁盘缓存大小的数据，而不是分多次的去读。所以要想得到一个最优的buffer值，我们必须得知道磁盘每次读的块大小和其缓存大小，然后根据多次试验的结果来得到最佳的buffer大小。</p>
<p>Java IO：BufferedReader和BufferedWriter</p>
<p>BufferedReader、BufferedWriter 的作用基本和BufferedInputStream、BufferedOutputStream一致，具体用法和原理都差不多 ，只不过一个是面向字符流一个是面向字节流。同样，我们将改造字符流中的例4，给其加上buffer功能，看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void readByBufferedReader() throws IOException &#123;</div><div class="line">       File file = new File( &quot;d:/test.txt&quot;);</div><div class="line">        // 在字符流基础上用buffer流包装，也可以指定buffer的大小</div><div class="line">       Reader reader = new BufferedReader( new FileReader(file),2*1024);</div><div class="line">        char[] byteArray = new char[( int) file.length()];</div><div class="line">        int size = reader.read( byteArray);</div><div class="line">       System. out.println( &quot;大小:&quot; + size + &quot;;内容:&quot; + new String(byteArray));</div><div class="line">        reader.close();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>转载请说明出处，原文链接: <a href="http://blog.csdn.net/suifeng3051/article/details/48344587" target="_blank" rel="external">http://blog.csdn.net/suifeng3051/article/details/48344587</a></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>