<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Java集合类 - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-10-07T14:10:56.000Z">October 7, 2017</time><h1 class="post__title"><a href="/2017/10/07/Java集合类/">Java集合类</a></h1><div class="post__main echo"><p>Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、数组、映射等（java.util.*）<br>java集合主要可以划分为四部分：List列表、Set集合、Map映射、工具类（Iterator、Enumeration、Arrays、Collections）</p>
<p><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/Inter.png?raw=true" alt="Inter"><br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/Util.png?raw=true" alt="Util"><br>我们的讲解会按上图从左到右进行讲解，分别是以下几个部分：<br>1、工具类<br>2、Collection<br>3、Map</p>
<p><font size="5">工具类</font><br>工具类包括以下几个部分<br>1、Iterator迭代器<br>2、Enumeration枚举类<br>3、Arrays<br>4、Collections</p>
<hr>
<p>1、Iterator(java.util.Iterator)<br><code>public interface Iterable&lt;T&gt;</code><br>迭代器接口，这个接口比较简单，我们使用的foreach的来源也是从这里开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int x : arr)&#123;</div><div class="line">	System.out.println(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的优势在于不用知道集合的内部结构，只是以一种逻辑来遍历集合。<br>加入没有迭代器，我们遍历数组需要这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int[] arrays = new int[10];</div><div class="line">for(int i = 0;i &lt; arrays.length;i++)&#123;</div><div class="line">	int a = arrays[i];</div><div class="line">    System.out.println(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>遍历ArrayList我们这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line">for(int i = 0;i &lt; list.size(); i++ ) &#123;</div><div class="line">	String str = list.get(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&gt;<br>这个时候我们考虑另外一点：如果我们不知道集合内部的大小，或是不知道集合内部的数据结构，显然，我们是无法进行操作的，这时，Iterator就出现了：<br>它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。<br>以下是它的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Iterator&#123;</div><div class="line">	boolean hasNext();</div><div class="line">    Object next());</div><div class="line">    void remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List L = new ArrayList();</div><div class="line">Iterator iter = L.iterator();</div><div class="line">while(iter.hasNext())&#123;</div><div class="line">	Srting str = (String)iter.next();</div><div class="line">    System.out.println(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(1)当创建完成指向某个集合或者容器的Iterator对象是，这是的指针其实指向的是第一个元素的上方，即指向一个空<br>(2)当调用hasNext方法的时候，只是判断下一个元素的有无，并不移动指针<br>(3)当调用next方法的时候，向下移动指针，并且返回指针指向的元素，如果指针指向的内存中没有元素，会报异常。<br>(4)remove方法删除的元素是指针指向的元素。如果当前指针指向的内存中没有元素，那么会抛出异常。<br>ArrayList的API中使用了Iterator<br>(5))调用next()方法后才可以调用remove()方法,而且每次调用next()后最多只能调用一次remove()方法,否则抛出IllegalStateException异常.</p>
<p><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/ArrayList.png?raw=true" alt="ArrayList"><br>ListIterator<br><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {}</code><br>ListIterator是一个继承于Iterator的接口，它是队列迭代器。专门用于便利List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等API接口。</p>
<p>2、Enumeration（枚举）接口的作用和Iterator类似，只提供了遍历Vector和HashTable类型集合元素的功能，不支持元素的移除操作。<br>Enumeration有两个方法：<br>（1）<code>boolean hasMoreElements();</code><br>是否还有元素，如果有返回true，否则表示至少含有一个元素<br>（2）<code>E nextElement();</code><br>如果Enumeration枚举对象还有元素，返回对象只能的下一个元素，否则抛出NoSuchElementException异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">import java.util.Enumeration;</div><div class="line">import java.util.Vector;</div><div class="line"></div><div class="line">public class ArrayL &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Vector v = new Vector();</div><div class="line">		v.addElement(&quot;a&quot;);</div><div class="line">		v.addElement(&quot;b&quot;);</div><div class="line">		v.addElement(&quot;c&quot;);</div><div class="line">		v.addElement(&quot;d&quot;);</div><div class="line">		Enumeration e = v.elements();</div><div class="line">		while(e.hasMoreElements())&#123;</div><div class="line">			String value = (String)e.nextElement();</div><div class="line">			System.out.println(value);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Iterator和Enumeration的区别:Iterator是用来替代Enumeration的,Enumeration中只定义了两个方法,不具备删除功能.</p>
<p>3、Arrays<br>This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists.<br>The methods in this class all throw a NullPointerException, if the specified array reference is null, except where noted.<br>反正大概意思就是有许多操作的方法（排序及搜索），此类还包含一个允许将数组作为列表来查看的静态工厂。<br>然后如果数组引用为空，会指定NullPointerException异常</p>
<p>这里再说一下，看到有人问Arrays和Array的区别：<br>1、java.lang.reflect.Array提供了创建和访问java数组的方法<br>2、java.util.Arrays主要用于操作数组<br>Array好比是种植出来的水果，Arrays则是对水果进行包装处理，可以制成水果罐头，也可以制成水果干。为什么弄出两个容易搞混的概念来？如果把Arrays类的方法都放到Array类里，那么Array类的职责太多了，可复用性就越小，另外，加剧了耦合性，如果一个职责变化，可能导致另一职责变化。</p>
<p>4、Collections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。<br>Collection 和 Collections的区别：<br>Collections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。</p>
<p>Collection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有Set和List,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。<br>Collections主要做一下四件事：<br>(1)排序操作<br>(2)查找、替换操作<br>(3)同步控制<br>Collectons提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。<br>(4)设置不可变集合<br>emptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。<br>singletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。<br>unmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。<br>上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。</p>
<p><font size="5">Collection</font><br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/Collection.png?raw=true" alt="Collection"><br>Collection是一个接口，它主要的两个分支是：List 和 Set。<br>List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！<br>List和Set都有它们各自的实现类。<br>  为了方便，我们抽象出了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。<br>  另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。<br><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}</code><br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/cmethod1.png?raw=true" alt="cmethod1"><br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/cmethod2.png?raw=true" alt="cmethod2"></p>
<p>其实无非就是CRUD而已，我们只要懂得一种，则放之四海而皆准。<br>1、接口<br>（1）List：有序队列，每个元素都有它的索引，实现类有LinkedList、ArrayList、Vector、Stack<br>List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。<br>（2）Set：不允许有重复元素的集合，HashSet、TreeSet<br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/set.png?raw=true" alt="set"><br>（3）Iterator和ListIterator在上文有讲解<br>2、抽象类<br>（1）AbstractCollection：AbstractCollection是一个抽象类，它实现了Collection中除iterator()和size()之外的函数。<br><code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {}</code><br>AbstractCollection的主要作用：它实现了Collection接口中的大部分函数。从而方便其它类实现Collection，比如ArrayList、LinkedList等，它们这些类想要实现Collection接口，通过继承AbstractCollection就已经实现了大部分的接口了。<br>（2）AbstractList:AbstractList是一个继承于AbstractCollection，并且实现List接口的抽象类。它实现了List中除size()、get(int location)之外的函数。<br><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {}</code><br>AbstractList的主要作用：它实现了List接口中的大部分函数。从而方便其它类继承List。<br>另外，和AbstractCollection相比，AbstractList抽象类中，实现了iterator()接口。<br>（3）AbstractSet：AbstractSet是一个继承于AbstractCollection，并且实现Set接口的抽象类。由于Set接口和Collection接口中的API完全一样，Set也就没有自己单独的API。和AbstractCollection一样，它实现了List中除iterator()和size()之外的函数。<br><code>public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {}</code><br>AbstractSet的主要作用：它实现了Set接口中的大部分函数。从而方便其它类实现Set接口。<br>2）实现类<br>（1）ArrayList<br>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。<br>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。<br>1) ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。<br>2) 当ArrayList容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。<br>3) ArrayList的克隆函数，即是将全部元素克隆到一个数组中。<br>4) ArrayList实现java.io.Serializable的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。<br>（2）LinkedList<br>LinkedList也和ArrayList一样实现了List接口，但是它执行插入和删除操作时比ArrayList更加高效，因为它是基于链表的。基于链表也决定了它在随机访问方面要比ArrayList逊色一点。<br>1) LinkedList 实际上是通过双向链表去实现的。<br>        它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。<br>2) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。<br>3) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。<br>4) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。<br>（3）Stack<br>先进后出，与Queue相反，这个，我就懒得说了<br>1) Stack实际上也是通过数组去实现的。<br>       执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。<br>       执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。<br>       执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。<br>2) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。<br>（4）Vector<br>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。<br>Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。<br>和ArrayList不同，Vector中的操作是线程安全的。<br>1) Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。<br>2) 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。<br>3) Vector的克隆函数，即是将全部元素克隆到一个数组中。</p>
<p>总结：如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。<br>(1) 对于需要快速插入，删除元素，应该使用LinkedList。<br>(2) 对于需要快速随机访问元素，应该使用ArrayList。<br>(3) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类。<br>（5）HashSet<br>HashSet 是一个没有重复元素的集合。<br>它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。<br>HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。<br>1) HashSet继承于AbstractSet，并且实现了Set接口。<br>2) HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。<br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/Hashset.png?raw=true" alt="hashset"></p>
<p>（6）TreeSet<br>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<e>, Cloneable, java.io.Serializable接口。<br>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。<br>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br>TreeSet 实现了Cloneable接口，意味着它能被克隆。<br>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。</e></p>
<p>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。<br>TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。<br>另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。</p>
<p><font size="5">Map</font><br><img src="https://github.com/RuiBeef/RuiBeef.github.io/blob/master/img/util/Map.png?raw=true" alt="Map"><br>Map是一个映射接口，AbstractMap实现了Map接口中的大部分API，HaspMap、TreeMap、WeakHaspMap继承于AbstractMap接口，Hashtabl继承与Dictionary但实现了Map接口<br><code>public interface Map&lt;K,V&gt; { }</code><br>Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。<br>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。<br>Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。<br>Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。<br>1）接口<br>1、Entry<br><code>interface Entry&lt;K,V&gt; { }</code><br>Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。<br>2、AbstractMap<br><code>public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; {}</code><br>(1)要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。</p>
<p>(2)要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。</p>
<p>3、SortMap<br>SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。<br>SortedMap的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）<br>2）实现类<br>1、HashMap<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<p>2、Hashtable<br>和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</p>
<p>Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。</p>
<p>3、TreeMap<br>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。<br>TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。<br>TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。<br>TreeMap 实现了Cloneable接口，意味着它能被克隆。<br>TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。</p>
<p>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。<br>另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。</p>
<p>1) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。<br>2)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>