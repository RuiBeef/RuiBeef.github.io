<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="RuiBeef"><meta name="description" content="不知道该说什么，但放点东西显得和谐一点"><link rel="alternative" href="/atom.xml" title="RuiBeef's Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>java Socket编程 - RuiBeef's Blog</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">RuiBeef's Blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2017-10-10T12:58:21.000Z">October 10, 2017</time><h1 class="post__title"><a href="/2017/10/10/java-Socket编程/">java Socket编程</a></h1><div class="post__main echo"><p>我们学会了使用IO流。<br>但是我们很多情况都是使用File流来存储数据，然后再另一个类中读取这个文件。<br>现实中，确实会使用IO流，将我们想要的数据进行序列化，转化成字节流的方式进行传输，这也就是我们序列化和反序列化的使用。<br>然而，当我们使用微信、QQ、MSM的时候，想像一下，我想和你聊天，然后我说一句话，你收到一个文件。。。<br>这像话吗？<br>我们使用电脑版的微信，谁在微信安装位置见到过无数交流文件？</p>
<p>所以呢，我们机智的java语言开发大神就想到了使用socket（我觉得是从C语言之类的学过来的）</p>
<p>作为渣渣的我，也只能呆呆的看大神是怎么做的（鼓掌喊666就好了）</p>
<p>首先，我们要知道Java Socket是什么来的？</p>
<p>Socket：套接字。这个名字好难听，大概类似于一个暗号吧，主要描述的是IP地址和端口（至于IP地址和端口是什么，我们下文再说），我们通过Socket，将两个（或多个）不同的计算机进行联系，从而进行通信。</p>
<p>我们下面来讲一下相关概念：<br>一、网络基础知识<br>1、两台计算机间进行通讯需要以下三个条件<br>（1）IP地址：大概类似于我们说，A住到XX街道<br>（2）协议：然后我们坐车（或坐船什么的）过去<br>（3）端口号：找到该街道时，我们要到特定的门牌号去找这个家伙聊天</p>
<p>2、IP地址一般都是32位二进制，127.0.0.1，我们的回环地址，这个大家应该都知道。但是在网络上，我们会获取一个网络号，这个我们下面会说到（待会贴代码），我们是靠这个网络号去寻找对方。</p>
<p>3、协议<br>协议呢，TCP/IP协议大家也不会没听过吧，TCP-Transmission Control Protocol传输控制协议，IP-Internet Protocol互联网协议，再加多一个UDP-User Data Protocol用户数据报协议</p>
<p>（1）UDP是一种无连接的协议，这就意味着我们每次发送数据报时，需要同时发送本机的socket描述符和接收端的socket描述符。因此，我们在每次通信时都需要发送额外的数据。</p>
<p>（2）和UDP不同，TCP是一种基于连接的协议。在使用流通信之前，我们必须在通信的一对儿socket之间建立连接。其中一个socket作为服务器进行监听连接请求。另一个则作为客户端进行连接请求。一旦两个socket建立好了连接，他们可以单向或双向进行数据传输。</p>
<p>4、五层模型<br>其实还有七层模型什么的，但我懒，我就选五层就好了<br>应用层：HTTP、FTP、SMTP、Telnet<br>传输层：TCP/IP<br>网络层：这里就是路由的最高层，我们的网络地址要从路由表中去寻找<br>数据链路层：这里涉及到物理地址什么的，本篇不会讲到（主要是我忘了）<br>物理层：网线、双绞线、网卡等，肉眼可以看到的东西</p>
<p>5、端口<br>当我们打开微信、又上了QQ，这个时候，如果要同时在这两个软件上面有信息传递过来，想象一下，用一个端口进行通信，QQ会不会把信息传到微信，微信把信息传到QQ？<br>所以呢，我们要知道，一台主机为了区分多个不同的应用程序，所以有了多个不同的端口，端口号的范围从0~65535，其中0~1023位为系统保留（所以呢，电脑还是对我们有所保留啊）<br>HTTP（超文本传输协议）：80（有名的80端口）；FTP（文件传输协议）：21；Telnet（Internet远程登陆服务的标准协议）：23.</p>
<p>IP地址+端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础</p>
<p>6、Socket套接字<br>Socket原理：<br>通信的两端都有Socket，网络通信其实就是Socket之间的通信，数据在两个Socket之间通过IO进行传输</p>
<p>7、Java中的网络支持<br>InetAddress：用于标识网络上的硬件资源，主要是IP地址<br>URL：统一资源定位符，通过URL可以直接读取或写入网络上的数据<br>Sockets：使用TCP协议实现网络通信Socket相关的类<br>Datagram：使用UDP协议，将数据保存在用户数据报中，通过网络今夕通信</p>
<p>二、InetAddress<br>这个时候我们先贴个代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InetAddress a = InetAddress.getLocalHost();</div><div class="line">		System.out.println(a.getHostName());</div><div class="line">		System.out.println(a.getHostAddress());</div></pre></td></tr></table></figure></p>
<p>之个代码可以获取我们的计算机名及IP地址<br>当我们没有联网，我们获取的IP地址是127.0.0.1,而我们联网后，获取的地址则是网络所在的IP地址。<br><img src="" alt="InetAddress"><br><img src="" alt="InetAddress2"><br>当然，如果你想获取其他主机的InetAddress实例，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InetAddress address2 =InetAddress.getByName(&quot;其他主机名&quot;);</div><div class="line">InetAddress address2 =InetAddress.getByName(&quot;其他IP地址&quot;);</div></pre></td></tr></table></figure></p>
<p>三、URL类<br>1、URL（统一资源定位符）和URI（统一资源标识符）是一对容易让人混淆的东西，这里我们趁机也说一下：<br><img src="" alt="URI"><br>看图我们可以看到URI分为URL和URN（统一资源名称）两个东西，URL是一种具体的URI，它不仅唯一标识资源而且还提供了定位该资源的信息，URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">URL baidu =new URL(&quot;http://www.baidu.com&quot;);</div><div class="line">URL url =new URL(baidu,&quot;/index.html?username=tom#test&quot;);//？表示参数，#表示锚点</div><div class="line">url.getProtocol();//获取协议</div><div class="line">url.getHost();//获取主机</div><div class="line">url.getPort();//如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1</div><div class="line">url.getPath();//获取文件路径</div><div class="line">url.getFile();//文件名，包括文件路径+参数</div><div class="line">url.getRef();//相对路径，就是锚点，即#号后面的内容</div><div class="line">url.getQuery();//查询字符串，即参数</div></pre></td></tr></table></figure>
<p>2、使用URL读取网页内容<br>有一天，老师叫我们做一个简单的网页，可是呢，我懒，所以我是这样做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws IOException&#123;</div><div class="line">		URL url = new URL(&quot;https://ruibeef.github.io/&quot;);</div><div class="line">		InputStream is = url.openStream();//通过openStream方法获取资源的字节输入流</div><div class="line">		InputStreamReader isr = new InputStreamReader(is,&quot;UTF-8&quot;);;//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码</div><div class="line">		BufferedReader br = new BufferedReader(isr);//为字符输入流添加缓冲，提高读取效率</div><div class="line">		String data = br.readLine();</div><div class="line">		while(data != null)&#123;</div><div class="line">			System.out.println(data);</div><div class="line">			data = br.readLine();</div><div class="line">		&#125;</div><div class="line">		br.close();</div><div class="line">		isr.close();</div><div class="line">		is.close();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>于是我打了n多次换行。。。<br><img src="" alt="OutStream"></p>
<p>四、TCP编程<br>1、TCP协议是面向连接的、可靠的、有序的、以字节流的方式发送数据，通过三次握手方式建立连接，形成传输数据的通道，在连接中进行大量数据的传输，效率会稍低<br>2、Java中基于TCP协议实现网络通信的类<br>客户端的Socket类<br>服务器端的ServerSocket类<br>3、TCP适合于诸如远程登录(rlogin,telnet)和文件传输（FTP）这类的网络服务。因为这些需要传输的数据的大小不确定。而UDP相比TCP更加简单轻量一些。UDP用来实现实时性较高或者丢包不重要的一些服务。在局域网中UDP的丢包率都相对比较低。<br>4、Socket通信的步骤<br>① 创建ServerSocket和Socket<br>② 打开连接到Socket的输入/输出流<br>③ 按照协议对Socket进行读/写操作<br>④ 关闭输入输出流、关闭Socket<br>5、服务器端：<br>① 创建ServerSocket对象，绑定监听端口<br>② 通过accept()方法监听客户端请求<br>③ 连接建立后，通过输入流读取客户端发送的请求信息<br>④ 通过输出流向客户端发送乡音信息<br>⑤ 关闭相关资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.Reader;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class ServerClient &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		int port = 8920;</div><div class="line">		try&#123;</div><div class="line">			ServerSocket server = new ServerSocket(port);</div><div class="line">			Socket socket = server.accept();</div><div class="line">			Reader reader = new InputStreamReader(socket.getInputStream());</div><div class="line">			char chars[] = new char[1024];</div><div class="line">			int len;</div><div class="line">			StringBuilder builder = new StringBuilder();</div><div class="line">			while((len=reader.read(chars)) != -1)&#123;</div><div class="line">				builder.append(new String(chars,0,len));</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;Receive from client message=:&quot;+builder);</div><div class="line">			reader.close();</div><div class="line">			socket.close();</div><div class="line">			server.close();</div><div class="line">		&#125;catch(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6、客户端：<br>① 创建Socket对象，指明需要连接的服务器的地址和端口号<br>② 连接建立后，通过输出流想服务器端发送请求信息<br>③ 通过输入流获取服务器响应的信息<br>④ 关闭响应资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package study;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.OutputStreamWriter;</div><div class="line">import java.io.Writer;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class ClientSocket &#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		String host = &quot;127.0.0.1&quot;;</div><div class="line">		int port = 8920;</div><div class="line">		try&#123;</div><div class="line">			Socket client = new Socket(host,port);</div><div class="line">			Writer writer = new OutputStreamWriter(client.getOutputStream());</div><div class="line">			writer.write(&quot;Hello I am your father!!&quot;);</div><div class="line">			writer.flush();</div><div class="line">			writer.close();</div><div class="line">			client.close();</div><div class="line">		&#125;catch(IOException e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="" alt="receive"></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java基础/">Java基础</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2017 RuiBeef</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>